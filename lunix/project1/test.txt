#!/bin/bash

classify_command() {
    description=$("$1" --help |awk '/^Usage:/ {p=1; next} p && NF; /^$/ {exit}')
        
    if [[ $description == *"text manipulation"* || $description == *"string operations"* || $description == *"working with files"* || $description == *"FILE"* || $description == *"characters"* || $description == *"regular expressions"* || $description == *"data transformation"* || $description == *"text search"* || $description == *"pattern matching"* || $description == *"line editing"* || $description == *"word processing"* || $description == *"file comparison"* || $description == *"text formatting"* || $description == *"sed usage"* || $description == *"awk usage"* || $description == *"text extraction"* || $description == *"text sorting"* || $description == *"string substitution"* ]]
    then
        text+=("$1")
    fi
        
    if [[ $description == *"file operations"* || $description == *"directory management"* || $description == *"permissions"* || $description == *"file compression"* || $description == *"move"* || $description == *"DIRECTORY(ies)"* || $description == *"Create"* || $description == *"metadata manipulation"* || $description == *"file linking"* || $description == *"cp"* || $description == *"file searching"* || $description == *"file deletion"* || $description == *"Rename"* || $description == *"file mode"* || $description == *"disk usage"* || $description == *"file permissions"* ]] 
    then
        files+=("$1")
    fi
        
    if [[ $description == *"print information"* || $description == *"display output"* || $description == *"formatting output"* || $description == *"terminal formatting"* || $description == *"information retrieval"* || $description == *"system status"* || $description == *"command output"* || $description == *"system"* || $description == *"column manipulation"* || $description == *"pager usage"* || $description == *"system logs"* || $description == *"system monitoring"* || $1 == *"ps"* || $description == *"environment variables"* || $description == *"system configuration"* || $description == *"print to console"* || $description == *"printer output"* ]] 
    then
        display+=("$1")
    fi
}



numOfCommands=20
commands=(touch mkdir ls tail mv rm rmdir cat head grep stat chmod ps cp date wc diff paste sort tr)
commands=($(echo "${commands[@]}" | tr ' ' '\n' | sort))



#mkae a directory for the whole files

mkdir project



cd project

echo "loading data..."

#create 13 files a file for each command

for ((i=0;i<numOfCommands;i++)){ 

    if [ ! -e ${commands[i]}.txt ]
    then

        touch ${commands[i]}.txt

    fi
}

touch test.txt
touch test2.txt
mkdir testDir

#descreption:
for ((i=0;i<numOfCommands;i++))
{
    echo "" >> ${commands[i]}.txt
    echo "---------------------------------------------------------------------------" >> ${commands[i]}.txt
    echo -e "\e[32m>${commands[i]}\e[0m" > ${commands[i]}.txt
    echo -e "\e[1;31mDescription:\e[0m" >> ${commands[i]}.txt
    man ${commands[i]} | awk '/^DESCRIPTION$/,/^$/' | sed -e 's/DESCRIPTION//g'  >> ${commands[i]}.txt
}

#version
for ((i=0;i<numOfCommands;i++))
{
    echo -e  "\e[1;31mversion:\e[0m" >> ${commands[i]}.txt
    ${commands[i]} --version | head -n 1 | grep -oP '([0-9]+[.][0-9]+([.][0-9]+)?)' >> ${commands[i]}.txt 
}

#kernal version 
for ((i=0;i<numOfCommands;i++))
{
    echo -e  "\e[1;31mkernla Version History\e[0m" >> ${commands[i]}.txt
    uname -r >> ${commands[i]}.txt
}

   
#example
for ((i=0;i<numOfCommands;i++))
{
    echo -e  "\e[1;31mExample\e[0m" >> ${commands[i]}.txt
    if [ ${commands[i]} == "ps" ] 
    then
        ${commands[i]} --help | sed -n '3p' | cut -d ' ' -f 2- | sed -e 's/\[options\]//g' -e 's/\[OPTION\]//g' -e 's/ \.\.\./ /g' -e 's/\.\.\./ /g' -e 's/FILES/test.txt test2.txt/g'  -e 's/\(\[FILE\]\|FILE\)/test.txt/g' -e 's/PATTERNS/hello/g' -e 's/DIRECTORY/testDir/g' -e 's/\[-T\]//' -e 's/SOURCE/test.txt/g' -e 's/DEST/\.\.\/ /g' -e 's/MODE\[,MODE\]/+x/g' -e 's/SET1/hello/g' -e 's/\[SET2\]/hi/g' -e 's/\[\(<switches>\)\]//g' -e 's/\[+FORMAT\]//g' >> ${commands[i]}.txt 
        $(${commands[i]} --help | sed -n '3p' | cut -d ' ' -f 2- | sed -e 's/\[options\]//g' -e 's/\[OPTION\]//g' -e 's/ \.\.\./ /g' -e 's/\.\.\./ /g' -e 's/FILES/test.txt test2.txt/g'  -e 's/\(\[FILE\]\|FILE\)/test.txt/g' -e 's/PATTERNS/hello/g' -e 's/DIRECTORY/testDir/g' -e 's/\[-T\]//' -e 's/SOURCE/test.txt/g' -e 's/DEST/\.\.\/ /g' -e 's/MODE\[,MODE\]/+x/g' -e 's/SET1/hello/g' -e 's/\[SET2\]/hi/g' -e 's/\[\(<switches>\)\]//g' -e 's/\[+FORMAT\]//g')  >> ${commands[i]}.txt & 

    else
        ${commands[i]} --help | head -n 1 | cut -d ' ' -f 2- | sed -e 's/\[OPTION\]//g' -e 's/ \.\.\./ /g' -e 's/\.\.\./ /g' -e 's/FILES/test.txt test2.txt/g'  -e 's/\(\[FILE\]\|FILE\)/test.txt/g' -e 's/PATTERNS/hello/g' -e 's/DIRECTORY/testDir/g' -e 's/\[-T\]//' -e 's/SOURCE/test.txt/g' -e 's/DEST/\.\.\/ /g' -e 's/MODE\[,MODE\]/+x/g' -e 's/SET1/hello/g' -e 's/\[SET2\]/hi/g' -e 's/\[\(<switches>\)\]//g' -e 's/\[+FORMAT\]//g' >> ${commands[i]}.txt 
        $(${commands[i]} --help | head -n 1 | cut -d ' ' -f 2- | sed -e 's/\[OPTION\]//g' -e 's/ \.\.\./ /g' -e 's/\.\.\./ /g' -e 's/FILES/test.txt test2.txt/g'  -e 's/\(\[FILE\]\|FILE\)/test.txt/g' -e 's/PATTERNS/hello/g' -e 's/DIRECTORY/testDir/g' -e 's/\[-T\]//' -e 's/SOURCE/test.txt/g' -e 's/DEST/\.\.\/ /g' -e 's/MODE\[,MODE\]/+x/g' -e 's/SET1/hello/g' -e 's/\[SET2\]/hi/g' -e 's/\[\(<switches>\)\]//g' -e 's/\[+FORMAT\]//g')   >> ${commands[i]}.txt 2>&1 &
    fi
}

#related commandsd
for ((i=0;i<numOfCommands;i++))
{
    echo -e  "\e[1;31mRelated Commands\e[0m" >> ${commands[i]}.txt
    compgen -c | grep ${commands[i]} >> ${commands[i]}.txt
    echo "---------------------------------------------------------------------------" >> ${commands[i]}.txt
    echo ""  >> ${commands[i]}.txt
}

echo "data loaded"

echo "classifying commands..."

text=()
files=()
display=()
flag=1

for command in "${commands[@]}" 
do
    classify_command "$command"
done

echo "all commands classified successsfully"

is_subword() {
    local string="$1"
    local subword="$2"
    [[ ${string,,} =~ ${subword,,} ]] && return 0 || return 1
}


while true
do
  echo "1. verfy files"
  echo "2. recommend "
  echo "3. find command"
  echo "4. find content"
  echo "5. done"
  echo "6. clear terminal"
  read -p "choice:" userInput

  case $userInput in
    1) 
        echo "creating file..."

        cd ../
        cat "project/${commands[0]}.txt" > new.txt &
        for ((i=1;i<numOfCommands;i++)) 
        {

            cat "project/${commands[i]}.txt" >> new.txt &
        }
    echo "files created successfully"
    echo "verefying files..."
    cmp --silent old.txt new.txt
    if [ $? -eq 0 ] 
    then
        echo "your file is up to date."
    else
        echo "your file needs update:"
        echo "different lines:"
        echo $(diff old.txt new.txt | head -n 1)
    fi
    cd project
    ;;

    2) 
    
    read -p "using command: " input
    related_list=()

    if [[ " ${text[@]} " =~ " $input " ]]
    then
        related_list+=("${text[@]}")
        flag=0
    fi
    if [[ " ${files[@]} " =~ " $input " ]] 
    then
        related_list+=("${files[@]}")
        flag=0
    fi
    if [[ " ${display[@]} " =~ " $input " ]] 
    then
        related_list+=("${display[@]}")
        flag=0
    fi
    if [ $flag -eq 1 ]
    then
        echo "Command: '$input' not found."
    fi
    if [ $flag -eq 0 ]
    then
    echo "recommendations: "
        for command in "${related_list[@]}" 
        do
            if [[ "$command" != "$user_command" ]] 
            then
                echo "$command"
            fi
        done

        while true
        do
            read -p "Enter your choice (first-0) (or 'q' to quit): " in

            if [[ "$in" == "q" || "$in" == "Q" ]]
            then
                echo "Quitting..."
                break
            fi
            if ! [[ $in =~ ^[0-9]+$ ]]
            then
                echo " invalid input (numbers or [qQ] are only valid)"
            elif (($in >= 0 && $in <= ${#related_list[@]})) 
            then
                chosen_option=${related_list[$in]}
                echo "gettinjg file.."
                echo "printing file.."
                echo ""
                echo ""
                cat "$chosen_option.txt"
                break
            else
                echo "please enter a valid number."
            fi
        done
    fi
        
    ;;
    3)    
        read -p "what command are you looking for?" c

    
        commandFile="$c.txt"
        if [ -e "$commandFile" ]
        then    
            echo -e "\n $commandFile:\n"
            cat "$commandFile"
        else
            echo "sorry i cant find your command :("
        fi
    
    ;;
    4)
        read -p "What would you like to see?: " lookFor
        flaag=1


for command in "${commands[@]}"; do
    if [ -e "$command.txt" ]; then
        while IFS= read -r line; do
            if is_subword "$line" "$lookFor"; then
                for ((i = -3; i <= 0; i++)); do
                    if [ $((lineNumber + i)) -ge 1 ]; then
                        sed -n "$((lineNumber + i))p" "$command.txt"
                    fi
                done
                echo "results:"
                echo
                echo "$line"
                for ((i = 1; i <= 3; i++)); do
                    sed -n "$((lineNumber + i))p" "$command.txt"
                done
            fi
            ((lineNumber++))
        done < "$command.txt"
        lineNumber=1
    fi
done

if [ $flag -eq 1 ]; then
    echo "No matchings found in any file."
fi
    ;;
    5) 
        read -p "Do you want to provide feedback? (yes/no): " feedbackChoice
        if [[ "$feedbackChoice" == "yes" || "$feedbackChoice" == "Yes" ]]; then
            read -p "Please enter your feedback: " feedback
            echo "$feedback" >> feedback.txt
            echo "Thank you for your feedback! your feedback will be reviewed asap."
        else
            echo " Thank you for using our system!"
fi
                
        break;;

    6)

    clear
    ;;
    *) 
    
        echo "not a valid option";;
  esac
done